// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider   = "prisma-client-js"
    // Vercel optimization: reduce bundle size
    engineType = "library"
    // Generate client in node_modules for better caching
    output     = "../node_modules/.prisma/client"
}

datasource db {
    provider  = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

// Necessary for Next auth
model User {
    id                 String  @id @default(cuid())
    twitterId          String  @unique
    twitterImage       String?
    twitterUsername    String?
    twitterDisplayName String?

    isAnonymous Boolean @default(false) // Toggle for anonymous profile display

    // Basic stats (detailed stats in Stats model)
    totalRewards Int   @default(0)
    reputation   Float @default(0)

    // App Relations
    posts       Post[]
    votes       Vote[]
    comments    Comment[]
    userWallets UserWallet[]
    stats       Stats?

    @@map("users")
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model UserWallet {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Wallet details
    address        String // The actual wallet address
    userWalletName String? // User-friendly name like "My Main Wallet", "Trading Wallet"
    chainId        Int // Blockchain ID (1 = Ethereum, 137 = Polygon, etc.)
    isDefault      Boolean @default(false) // Primary wallet for rewards

    // Metadata
    lastUsed DateTime?

    @@unique([userId, address]) // User can't add same address twice
    @@map("user_wallets")
}

model Stats {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    userId String @unique
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Engagement stats
    totalLikes    Int @default(0) // Total upvotes received across all posts
    totalDislikes Int @default(0) // Total downvotes received
    totalViews    Int @default(0) // Total views across all posts
    totalComments Int @default(0) // Total comments received

    // Quality metrics
    communitySentiment Float @default(0) // Average sentiment score (-1 to 1)
    aiAccuracyRate     Float @default(0) // How often AI matches community validation

    // Activity stats
    totalPosts      Int       @default(0) // Total posts created
    consecutiveDays Int       @default(0) // Current streak
    longestStreak   Int       @default(0) // Best streak ever
    lastPostDate    DateTime?

    // Achievement metrics
    topThreeFinishes   Int @default(0) // How many times in top 3 of daily rankings
    perfectValidations Int @default(0) // Posts where AI and community perfectly agreed

    @@map("user_stats")
}

model Topic {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    title       String // "Bananas and Cars"
    description String? // Optional description
    date        DateTime @unique // The day this topic is active
    isActive    Boolean  @default(false)

    // AI keywords for recognition
    keywords String[] // ["banana", "car", "yellow fruit", "vehicle"]

    posts Post[]

    @@map("topics")
}

model Post {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    twitterId String
    user      User   @relation(fields: [twitterId], references: [twitterId], onDelete: Cascade)
    topicId   String
    topic     Topic  @relation(fields: [topicId], references: [id], onDelete: Cascade)

    // Image data
    imageUrl    String
    imageKey    String // Supabase storage key
    blurDataUrl String? // Base64 blur placeholder for Next.js Image component

    // AI Recognition (initial)
    aiDescription   String? // "Red car with yellow fruit"
    aiConfidence    Float? // 0.0 - 1.0
    aiKeywordsFound String[] // ["car", "yellow fruit"]
    aiProcessed     Boolean  @default(false)

    // Community validation
    humanDescription String? // From comments analysis
    validationStatus ValidationStatus @default(PENDING)

    // Engagement metrics
    totalViews Int   @default(0)
    sentiment  Float @default(0) // -1 to 1 based on votes

    // Rewards
    rewardPoints     Int     @default(0)
    rewardCalculated Boolean @default(false)

    // Relations
    votes    Vote[]
    comments Comment[]

    // Constraints - one post per user per topic
    @@unique([twitterId, topicId])
    @@map("posts")
}

model Vote {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())

    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    postId String
    post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

    type VoteType // UPVOTE, DOWNVOTE

    @@unique([userId, postId]) // One vote per user per post
    @@map("votes")
}

model Comment {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    postId String
    post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

    content String

    // AI analysis for validation
    aiProcessed        Boolean  @default(false)
    contributesToValid Boolean? // Does this comment help validate the post?

    @@map("comments")
}

//TODO: Investigate a better way to track post views i think the current way is not efficient

// View tracking for analytics
model PostView {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())

    postId    String
    userId    String? // nullable for anonymous views
    ipAddress String? // for anonymous tracking

    @@map("post_views")
}

// Reward transactions
model RewardTransaction {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())

    userId String
    postId String? // nullable for other reward types

    points Int
    reason String // "Daily post reward", "Engagement bonus", etc.

    @@map("reward_transactions")
}

// System settings
model SystemSettings {
    id    String @id @default(cuid())
    key   String @unique
    value String

    @@map("system_settings")
}

enum VoteType {
    UPVOTE
    DOWNVOTE
}

enum ValidationStatus {
    PENDING // Just posted, waiting for AI + community validation
    AI_VALIDATED // AI thinks it matches
    AI_REJECTED // AI thinks it doesn't match
    COMMUNITY_VALIDATED // Community agrees with AI
    COMMUNITY_REJECTED // Community disagrees with AI
    FINAL_APPROVED // Ready for rewards
    FINAL_REJECTED // No rewards
}
